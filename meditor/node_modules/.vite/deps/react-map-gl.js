import { i as __toESM, r as __toDynamicImportESM } from "./chunk-DNXwb8T0.js";
import { t as require_react } from "./react-DFGVWq73.js";
import { t as require_react_dom } from "./react-dom-BiiEQjyR.js";

//#region node_modules/react-map-gl/dist/esm/components/use-map.js
var import_react = /* @__PURE__ */ __toESM(require_react());
const MountedMapsContext = import_react.createContext(null);
const MapProvider = (props) => {
	const [maps, setMaps] = (0, import_react.useState)({});
	const onMapMount = (0, import_react.useCallback)((map, id = "default") => {
		setMaps((currMaps) => {
			if (id === "current") throw new Error("'current' cannot be used as map id");
			if (currMaps[id]) throw new Error(`Multiple maps with the same id: ${id}`);
			return {
				...currMaps,
				[id]: map
			};
		});
	}, []);
	const onMapUnmount = (0, import_react.useCallback)((id = "default") => {
		setMaps((currMaps) => {
			if (currMaps[id]) {
				const nextMaps = { ...currMaps };
				delete nextMaps[id];
				return nextMaps;
			}
			return currMaps;
		});
	}, []);
	return import_react.createElement(MountedMapsContext.Provider, { value: {
		maps,
		onMapMount,
		onMapUnmount
	} }, props.children);
};
function useMap$1() {
	var _a;
	const maps = (_a = (0, import_react.useContext)(MountedMapsContext)) === null || _a === void 0 ? void 0 : _a.maps;
	const currentMap = (0, import_react.useContext)(MapContext);
	return (0, import_react.useMemo)(() => {
		return {
			...maps,
			current: currentMap === null || currentMap === void 0 ? void 0 : currentMap.map
		};
	}, [maps, currentMap]);
}

//#endregion
//#region node_modules/react-map-gl/dist/esm/utils/deep-equal.js
/**
* Compare two points
* @param a
* @param b
* @returns true if the points are equal
*/
function arePointsEqual(a, b) {
	const ax = Array.isArray(a) ? a[0] : a ? a.x : 0;
	const ay = Array.isArray(a) ? a[1] : a ? a.y : 0;
	const bx = Array.isArray(b) ? b[0] : b ? b.x : 0;
	const by = Array.isArray(b) ? b[1] : b ? b.y : 0;
	return ax === bx && ay === by;
}
/**
* Compare any two objects
* @param a
* @param b
* @returns true if the objects are deep equal
*/
function deepEqual(a, b) {
	if (a === b) return true;
	if (!a || !b) return false;
	if (Array.isArray(a)) {
		if (!Array.isArray(b) || a.length !== b.length) return false;
		for (let i = 0; i < a.length; i++) if (!deepEqual(a[i], b[i])) return false;
		return true;
	} else if (Array.isArray(b)) return false;
	if (typeof a === "object" && typeof b === "object") {
		const aKeys = Object.keys(a);
		const bKeys = Object.keys(b);
		if (aKeys.length !== bKeys.length) return false;
		for (const key of aKeys) {
			if (!b.hasOwnProperty(key)) return false;
			if (!deepEqual(a[key], b[key])) return false;
		}
		return true;
	}
	return false;
}

//#endregion
//#region node_modules/react-map-gl/dist/esm/utils/transform.js
/**
* Make a copy of a transform
* @param tr
*/
function cloneTransform(tr) {
	const newTransform = tr.clone();
	newTransform.pixelsToGLUnits = tr.pixelsToGLUnits;
	return newTransform;
}
/**
* Copy projection from one transform to another. This only applies to mapbox-gl transforms
* @param src the transform to copy projection settings from
* @param dest to transform to copy projection settings to
*/
function syncProjection(src, dest) {
	if (!src.getProjection) return;
	const srcProjection = src.getProjection();
	if (!deepEqual(srcProjection, dest.getProjection())) dest.setProjection(srcProjection);
}
/**
* Capture a transform's current state
* @param transform
* @returns descriptor of the view state
*/
function transformToViewState(tr) {
	return {
		longitude: tr.center.lng,
		latitude: tr.center.lat,
		zoom: tr.zoom,
		pitch: tr.pitch,
		bearing: tr.bearing,
		padding: tr.padding
	};
}
/**
* Mutate a transform to match the given view state
* @param transform
* @param viewState
* @returns true if the transform has changed
*/
function applyViewStateToTransform(tr, props) {
	const v = props.viewState || props;
	let changed = false;
	if ("zoom" in v) {
		const zoom = tr.zoom;
		tr.zoom = v.zoom;
		changed = changed || zoom !== tr.zoom;
	}
	if ("bearing" in v) {
		const bearing = tr.bearing;
		tr.bearing = v.bearing;
		changed = changed || bearing !== tr.bearing;
	}
	if ("pitch" in v) {
		const pitch = tr.pitch;
		tr.pitch = v.pitch;
		changed = changed || pitch !== tr.pitch;
	}
	if (v.padding && !tr.isPaddingEqual(v.padding)) {
		changed = true;
		tr.padding = v.padding;
	}
	if ("longitude" in v && "latitude" in v) {
		const center = tr.center;
		tr.center = new center.constructor(v.longitude, v.latitude);
		changed = changed || center !== tr.center;
	}
	return changed;
}

//#endregion
//#region node_modules/react-map-gl/dist/esm/utils/style-utils.js
var refProps = [
	"type",
	"source",
	"source-layer",
	"minzoom",
	"maxzoom",
	"filter",
	"layout"
];
function normalizeStyle(style) {
	if (!style) return null;
	if (typeof style === "string") return style;
	if ("toJS" in style) style = style.toJS();
	if (!style.layers) return style;
	const layerIndex = {};
	for (const layer of style.layers) layerIndex[layer.id] = layer;
	const layers = style.layers.map((layer) => {
		let normalizedLayer = null;
		if ("interactive" in layer) {
			normalizedLayer = Object.assign({}, layer);
			delete normalizedLayer.interactive;
		}
		const layerRef = layerIndex[layer.ref];
		if (layerRef) {
			normalizedLayer = normalizedLayer || Object.assign({}, layer);
			delete normalizedLayer.ref;
			for (const propName of refProps) if (propName in layerRef) normalizedLayer[propName] = layerRef[propName];
		}
		return normalizedLayer || layer;
	});
	return {
		...style,
		layers
	};
}

//#endregion
//#region node_modules/react-map-gl/dist/esm/mapbox/mapbox.js
var DEFAULT_STYLE = {
	version: 8,
	sources: {},
	layers: []
};
var pointerEvents = {
	mousedown: "onMouseDown",
	mouseup: "onMouseUp",
	mouseover: "onMouseOver",
	mousemove: "onMouseMove",
	click: "onClick",
	dblclick: "onDblClick",
	mouseenter: "onMouseEnter",
	mouseleave: "onMouseLeave",
	mouseout: "onMouseOut",
	contextmenu: "onContextMenu",
	touchstart: "onTouchStart",
	touchend: "onTouchEnd",
	touchmove: "onTouchMove",
	touchcancel: "onTouchCancel"
};
var cameraEvents = {
	movestart: "onMoveStart",
	move: "onMove",
	moveend: "onMoveEnd",
	dragstart: "onDragStart",
	drag: "onDrag",
	dragend: "onDragEnd",
	zoomstart: "onZoomStart",
	zoom: "onZoom",
	zoomend: "onZoomEnd",
	rotatestart: "onRotateStart",
	rotate: "onRotate",
	rotateend: "onRotateEnd",
	pitchstart: "onPitchStart",
	pitch: "onPitch",
	pitchend: "onPitchEnd"
};
var otherEvents = {
	wheel: "onWheel",
	boxzoomstart: "onBoxZoomStart",
	boxzoomend: "onBoxZoomEnd",
	boxzoomcancel: "onBoxZoomCancel",
	resize: "onResize",
	load: "onLoad",
	render: "onRender",
	idle: "onIdle",
	remove: "onRemove",
	data: "onData",
	styledata: "onStyleData",
	sourcedata: "onSourceData",
	error: "onError"
};
var settingNames = [
	"minZoom",
	"maxZoom",
	"minPitch",
	"maxPitch",
	"maxBounds",
	"projection",
	"renderWorldCopies"
];
var handlerNames = [
	"scrollZoom",
	"boxZoom",
	"dragRotate",
	"dragPan",
	"keyboard",
	"doubleClickZoom",
	"touchZoomRotate",
	"touchPitch"
];
/**
* A wrapper for mapbox-gl's Map class
*/
var Mapbox = class Mapbox {
	constructor(MapClass, props, container) {
		this._map = null;
		this._internalUpdate = false;
		this._inRender = false;
		this._hoveredFeatures = null;
		this._deferredEvents = {
			move: false,
			zoom: false,
			pitch: false,
			rotate: false
		};
		this._onEvent = (e) => {
			const cb = this.props[otherEvents[e.type]];
			if (cb) cb(e);
			else if (e.type === "error") console.error(e.error);
		};
		this._onPointerEvent = (e) => {
			if (e.type === "mousemove" || e.type === "mouseout") this._updateHover(e);
			const cb = this.props[pointerEvents[e.type]];
			if (cb) {
				if (this.props.interactiveLayerIds && e.type !== "mouseover" && e.type !== "mouseout") e.features = this._hoveredFeatures || this._queryRenderedFeatures(e.point);
				cb(e);
				delete e.features;
			}
		};
		this._onCameraEvent = (e) => {
			if (!this._internalUpdate) {
				const cb = this.props[cameraEvents[e.type]];
				if (cb) cb(e);
			}
			if (e.type in this._deferredEvents) this._deferredEvents[e.type] = false;
		};
		this._MapClass = MapClass;
		this.props = props;
		this._initialize(container);
	}
	get map() {
		return this._map;
	}
	get transform() {
		return this._renderTransform;
	}
	setProps(props) {
		const oldProps = this.props;
		this.props = props;
		const settingsChanged = this._updateSettings(props, oldProps);
		if (settingsChanged) this._createShadowTransform(this._map);
		const sizeChanged = this._updateSize(props);
		const viewStateChanged = this._updateViewState(props, true);
		this._updateStyle(props, oldProps);
		this._updateStyleComponents(props, oldProps);
		this._updateHandlers(props, oldProps);
		if (settingsChanged || sizeChanged || viewStateChanged && !this._map.isMoving()) this.redraw();
	}
	static reuse(props, container) {
		const that = Mapbox.savedMaps.pop();
		if (!that) return null;
		const map = that.map;
		const oldContainer = map.getContainer();
		container.className = oldContainer.className;
		while (oldContainer.childNodes.length > 0) container.appendChild(oldContainer.childNodes[0]);
		map._container = container;
		const resizeObserver = map._resizeObserver;
		if (resizeObserver) {
			resizeObserver.disconnect();
			resizeObserver.observe(container);
		}
		that.setProps({
			...props,
			styleDiffing: false
		});
		map.resize();
		const { initialViewState } = props;
		if (initialViewState) if (initialViewState.bounds) map.fitBounds(initialViewState.bounds, {
			...initialViewState.fitBoundsOptions,
			duration: 0
		});
		else that._updateViewState(initialViewState, false);
		if (map.isStyleLoaded()) map.fire("load");
		else map.once("styledata", () => map.fire("load"));
		map._update();
		return that;
	}
	_initialize(container) {
		const { props } = this;
		const { mapStyle = DEFAULT_STYLE } = props;
		const mapOptions = {
			...props,
			...props.initialViewState,
			accessToken: props.mapboxAccessToken || getAccessTokenFromEnv() || null,
			container,
			style: normalizeStyle(mapStyle)
		};
		const viewState = mapOptions.initialViewState || mapOptions.viewState || mapOptions;
		Object.assign(mapOptions, {
			center: [viewState.longitude || 0, viewState.latitude || 0],
			zoom: viewState.zoom || 0,
			pitch: viewState.pitch || 0,
			bearing: viewState.bearing || 0
		});
		if (props.gl) {
			const getContext = HTMLCanvasElement.prototype.getContext;
			HTMLCanvasElement.prototype.getContext = () => {
				HTMLCanvasElement.prototype.getContext = getContext;
				return props.gl;
			};
		}
		const map = new this._MapClass(mapOptions);
		if (viewState.padding) map.setPadding(viewState.padding);
		if (props.cursor) map.getCanvas().style.cursor = props.cursor;
		this._createShadowTransform(map);
		const renderMap = map._render;
		map._render = (arg) => {
			this._inRender = true;
			renderMap.call(map, arg);
			this._inRender = false;
		};
		const runRenderTaskQueue = map._renderTaskQueue.run;
		map._renderTaskQueue.run = (arg) => {
			runRenderTaskQueue.call(map._renderTaskQueue, arg);
			this._onBeforeRepaint();
		};
		map.on("render", () => this._onAfterRepaint());
		const fireEvent = map.fire;
		map.fire = this._fireEvent.bind(this, fireEvent);
		map.on("resize", () => {
			this._renderTransform.resize(map.transform.width, map.transform.height);
		});
		map.on("styledata", () => {
			this._updateStyleComponents(this.props, {});
			syncProjection(map.transform, this._renderTransform);
		});
		map.on("sourcedata", () => this._updateStyleComponents(this.props, {}));
		for (const eventName in pointerEvents) map.on(eventName, this._onPointerEvent);
		for (const eventName in cameraEvents) map.on(eventName, this._onCameraEvent);
		for (const eventName in otherEvents) map.on(eventName, this._onEvent);
		this._map = map;
	}
	recycle() {
		const children = this.map.getContainer().querySelector("[mapboxgl-children]");
		children === null || children === void 0 || children.remove();
		Mapbox.savedMaps.push(this);
	}
	destroy() {
		this._map.remove();
	}
	redraw() {
		const map = this._map;
		if (!this._inRender && map.style) {
			if (map._frame) {
				map._frame.cancel();
				map._frame = null;
			}
			map._render();
		}
	}
	_createShadowTransform(map) {
		const renderTransform = cloneTransform(map.transform);
		map.painter.transform = renderTransform;
		this._renderTransform = renderTransform;
	}
	_updateSize(nextProps) {
		const { viewState } = nextProps;
		if (viewState) {
			const map = this._map;
			if (viewState.width !== map.transform.width || viewState.height !== map.transform.height) {
				map.resize();
				return true;
			}
		}
		return false;
	}
	_updateViewState(nextProps, triggerEvents) {
		if (this._internalUpdate) return false;
		const map = this._map;
		const tr = this._renderTransform;
		const { zoom, pitch, bearing } = tr;
		const isMoving = map.isMoving();
		if (isMoving) tr.cameraElevationReference = "sea";
		const changed = applyViewStateToTransform(tr, {
			...transformToViewState(map.transform),
			...nextProps
		});
		if (isMoving) tr.cameraElevationReference = "ground";
		if (changed && triggerEvents) {
			const deferredEvents = this._deferredEvents;
			deferredEvents.move = true;
			deferredEvents.zoom || (deferredEvents.zoom = zoom !== tr.zoom);
			deferredEvents.rotate || (deferredEvents.rotate = bearing !== tr.bearing);
			deferredEvents.pitch || (deferredEvents.pitch = pitch !== tr.pitch);
		}
		if (!isMoving) applyViewStateToTransform(map.transform, nextProps);
		return changed;
	}
	_updateSettings(nextProps, currProps) {
		const map = this._map;
		let changed = false;
		for (const propName of settingNames) if (propName in nextProps && !deepEqual(nextProps[propName], currProps[propName])) {
			changed = true;
			const setter = map[`set${propName[0].toUpperCase()}${propName.slice(1)}`];
			setter === null || setter === void 0 || setter.call(map, nextProps[propName]);
		}
		return changed;
	}
	_updateStyle(nextProps, currProps) {
		if (nextProps.cursor !== currProps.cursor) this._map.getCanvas().style.cursor = nextProps.cursor || "";
		if (nextProps.mapStyle !== currProps.mapStyle) {
			const { mapStyle = DEFAULT_STYLE, styleDiffing = true } = nextProps;
			const options = { diff: styleDiffing };
			if ("localIdeographFontFamily" in nextProps) options.localIdeographFontFamily = nextProps.localIdeographFontFamily;
			this._map.setStyle(normalizeStyle(mapStyle), options);
			return true;
		}
		return false;
	}
	_updateStyleComponents(nextProps, currProps) {
		const map = this._map;
		let changed = false;
		if (map.isStyleLoaded()) {
			if ("light" in nextProps && map.setLight && !deepEqual(nextProps.light, currProps.light)) {
				changed = true;
				map.setLight(nextProps.light);
			}
			if ("fog" in nextProps && map.setFog && !deepEqual(nextProps.fog, currProps.fog)) {
				changed = true;
				map.setFog(nextProps.fog);
			}
			if ("terrain" in nextProps && map.setTerrain && !deepEqual(nextProps.terrain, currProps.terrain)) {
				if (!nextProps.terrain || map.getSource(nextProps.terrain.source)) {
					changed = true;
					map.setTerrain(nextProps.terrain);
				}
			}
		}
		return changed;
	}
	_updateHandlers(nextProps, currProps) {
		var _a, _b;
		const map = this._map;
		let changed = false;
		for (const propName of handlerNames) {
			const newValue = (_a = nextProps[propName]) !== null && _a !== void 0 ? _a : true;
			if (!deepEqual(newValue, (_b = currProps[propName]) !== null && _b !== void 0 ? _b : true)) {
				changed = true;
				if (newValue) map[propName].enable(newValue);
				else map[propName].disable();
			}
		}
		return changed;
	}
	_queryRenderedFeatures(point) {
		const map = this._map;
		const tr = map.transform;
		const { interactiveLayerIds = [] } = this.props;
		try {
			map.transform = this._renderTransform;
			return map.queryRenderedFeatures(point, { layers: interactiveLayerIds.filter(map.getLayer.bind(map)) });
		} catch (_a) {
			return [];
		} finally {
			map.transform = tr;
		}
	}
	_updateHover(e) {
		var _a;
		const { props } = this;
		if (props.interactiveLayerIds && (props.onMouseMove || props.onMouseEnter || props.onMouseLeave)) {
			const eventType = e.type;
			const wasHovering = ((_a = this._hoveredFeatures) === null || _a === void 0 ? void 0 : _a.length) > 0;
			const features = this._queryRenderedFeatures(e.point);
			const isHovering = features.length > 0;
			if (!isHovering && wasHovering) {
				e.type = "mouseleave";
				this._onPointerEvent(e);
			}
			this._hoveredFeatures = features;
			if (isHovering && !wasHovering) {
				e.type = "mouseenter";
				this._onPointerEvent(e);
			}
			e.type = eventType;
		} else this._hoveredFeatures = null;
	}
	_fireEvent(baseFire, event, properties) {
		const map = this._map;
		const tr = map.transform;
		const eventType = typeof event === "string" ? event : event.type;
		if (eventType === "move") this._updateViewState(this.props, false);
		if (eventType in cameraEvents) {
			if (typeof event === "object") event.viewState = transformToViewState(tr);
			if (this._map.isMoving()) {
				map.transform = this._renderTransform;
				baseFire.call(map, event, properties);
				map.transform = tr;
				return map;
			}
		}
		baseFire.call(map, event, properties);
		return map;
	}
	_onBeforeRepaint() {
		const map = this._map;
		this._internalUpdate = true;
		for (const eventType in this._deferredEvents) if (this._deferredEvents[eventType]) map.fire(eventType);
		this._internalUpdate = false;
		const tr = this._map.transform;
		map.transform = this._renderTransform;
		this._onAfterRepaint = () => {
			syncProjection(this._renderTransform, tr);
			map.transform = tr;
		};
	}
};
Mapbox.savedMaps = [];
/**
* Access token can be provided via one of:
*   mapboxAccessToken prop
*   access_token query parameter
*   MapboxAccessToken environment variable
*   REACT_APP_MAPBOX_ACCESS_TOKEN environment variable
* @returns access token
*/
function getAccessTokenFromEnv() {
	let accessToken = null;
	if (typeof location !== "undefined") {
		const match = /access_token=([^&\/]*)/.exec(location.search);
		accessToken = match && match[1];
	}
	try {
		accessToken = accessToken || process.env.MapboxAccessToken;
	} catch (_a) {}
	try {
		accessToken = accessToken || process.env.REACT_APP_MAPBOX_ACCESS_TOKEN;
	} catch (_b) {}
	return accessToken;
}

//#endregion
//#region node_modules/react-map-gl/dist/esm/mapbox/create-ref.js
/** These methods may break the react binding if called directly */
var skipMethods = [
	"setMaxBounds",
	"setMinZoom",
	"setMaxZoom",
	"setMinPitch",
	"setMaxPitch",
	"setRenderWorldCopies",
	"setProjection",
	"setStyle",
	"addSource",
	"removeSource",
	"addLayer",
	"removeLayer",
	"setLayerZoomRange",
	"setFilter",
	"setPaintProperty",
	"setLayoutProperty",
	"setLight",
	"setTerrain",
	"setFog",
	"remove"
];
function createRef(mapInstance) {
	if (!mapInstance) return null;
	const map = mapInstance.map;
	const result = {
		getMap: () => map,
		getCenter: () => mapInstance.transform.center,
		getZoom: () => mapInstance.transform.zoom,
		getBearing: () => mapInstance.transform.bearing,
		getPitch: () => mapInstance.transform.pitch,
		getPadding: () => mapInstance.transform.padding,
		getBounds: () => mapInstance.transform.getBounds(),
		project: (lnglat) => {
			const tr = map.transform;
			map.transform = mapInstance.transform;
			const result$1 = map.project(lnglat);
			map.transform = tr;
			return result$1;
		},
		unproject: (point) => {
			const tr = map.transform;
			map.transform = mapInstance.transform;
			const result$1 = map.unproject(point);
			map.transform = tr;
			return result$1;
		},
		queryTerrainElevation: (lnglat, options) => {
			const tr = map.transform;
			map.transform = mapInstance.transform;
			const result$1 = map.queryTerrainElevation(lnglat, options);
			map.transform = tr;
			return result$1;
		},
		queryRenderedFeatures: (geometry, options) => {
			const tr = map.transform;
			map.transform = mapInstance.transform;
			const result$1 = map.queryRenderedFeatures(geometry, options);
			map.transform = tr;
			return result$1;
		}
	};
	for (const key of getMethodNames(map)) if (!(key in result) && !skipMethods.includes(key)) result[key] = map[key].bind(map);
	return result;
}
function getMethodNames(obj) {
	const result = /* @__PURE__ */ new Set();
	let proto = obj;
	while (proto) {
		for (const key of Object.getOwnPropertyNames(proto)) if (key[0] !== "_" && typeof obj[key] === "function" && key !== "fire" && key !== "setEventedParent") result.add(key);
		proto = Object.getPrototypeOf(proto);
	}
	return Array.from(result);
}

//#endregion
//#region node_modules/react-map-gl/dist/esm/utils/use-isomorphic-layout-effect.js
var useIsomorphicLayoutEffect = typeof document !== "undefined" ? import_react.useLayoutEffect : import_react.useEffect;
var use_isomorphic_layout_effect_default = useIsomorphicLayoutEffect;

//#endregion
//#region node_modules/react-map-gl/dist/esm/utils/set-globals.js
var globalSettings = [
	"baseApiUrl",
	"maxParallelImageRequests",
	"workerClass",
	"workerCount",
	"workerUrl"
];
function setGlobals(mapLib$1, props) {
	for (const key of globalSettings) if (key in props) mapLib$1[key] = props[key];
	const { RTLTextPlugin = "https://api.mapbox.com/mapbox-gl-js/plugins/mapbox-gl-rtl-text/v0.2.3/mapbox-gl-rtl-text.js" } = props;
	if (RTLTextPlugin && mapLib$1.getRTLTextPluginStatus && mapLib$1.getRTLTextPluginStatus() === "unavailable") mapLib$1.setRTLTextPlugin(RTLTextPlugin, (error) => {
		if (error) console.error(error);
	}, true);
}

//#endregion
//#region node_modules/react-map-gl/dist/esm/components/map.js
const MapContext = import_react.createContext(null);
function Map$1(props, ref, defaultLib) {
	const mountedMapsContext = (0, import_react.useContext)(MountedMapsContext);
	const [mapInstance, setMapInstance] = (0, import_react.useState)(null);
	const containerRef = (0, import_react.useRef)();
	const { current: contextValue } = (0, import_react.useRef)({
		mapLib: null,
		map: null
	});
	(0, import_react.useEffect)(() => {
		const mapLib$1 = props.mapLib;
		let isMounted = true;
		let mapbox;
		Promise.resolve(mapLib$1 || defaultLib).then((module) => {
			if (!isMounted) return;
			if (!module) throw new Error("Invalid mapLib");
			const mapboxgl = "Map" in module ? module : module.default;
			if (!mapboxgl.Map) throw new Error("Invalid mapLib");
			setGlobals(mapboxgl, props);
			if (!mapboxgl.supported || mapboxgl.supported(props)) {
				if (props.reuseMaps) mapbox = Mapbox.reuse(props, containerRef.current);
				if (!mapbox) mapbox = new Mapbox(mapboxgl.Map, props, containerRef.current);
				contextValue.map = createRef(mapbox);
				contextValue.mapLib = mapboxgl;
				setMapInstance(mapbox);
				mountedMapsContext === null || mountedMapsContext === void 0 || mountedMapsContext.onMapMount(contextValue.map, props.id);
			} else throw new Error("Map is not supported by this browser");
		}).catch((error) => {
			const { onError } = props;
			if (onError) onError({
				type: "error",
				target: null,
				originalEvent: null,
				error
			});
			else console.error(error);
		});
		return () => {
			isMounted = false;
			if (mapbox) {
				mountedMapsContext === null || mountedMapsContext === void 0 || mountedMapsContext.onMapUnmount(props.id);
				if (props.reuseMaps) mapbox.recycle();
				else mapbox.destroy();
			}
		};
	}, []);
	use_isomorphic_layout_effect_default(() => {
		if (mapInstance) mapInstance.setProps(props);
	});
	(0, import_react.useImperativeHandle)(ref, () => contextValue.map, [mapInstance]);
	const style = (0, import_react.useMemo)(() => ({
		position: "relative",
		width: "100%",
		height: "100%",
		...props.style
	}), [props.style]);
	const CHILD_CONTAINER_STYLE = { height: "100%" };
	return import_react.createElement("div", {
		id: props.id,
		ref: containerRef,
		style
	}, mapInstance && import_react.createElement(MapContext.Provider, { value: contextValue }, import_react.createElement("div", {
		"mapboxgl-children": "",
		style: CHILD_CONTAINER_STYLE
	}, props.children)));
}

//#endregion
//#region node_modules/react-map-gl/dist/esm/utils/apply-react-style.js
var import_react_dom$1 = require_react_dom();
var unitlessNumber = /box|flex|grid|column|lineHeight|fontWeight|opacity|order|tabSize|zIndex/;
function applyReactStyle(element, styles) {
	if (!element || !styles) return;
	const style = element.style;
	for (const key in styles) {
		const value = styles[key];
		if (Number.isFinite(value) && !unitlessNumber.test(key)) style[key] = `${value}px`;
		else style[key] = value;
	}
}

//#endregion
//#region node_modules/react-map-gl/dist/esm/components/marker.js
function Marker$1(props, ref) {
	const { map, mapLib: mapLib$1 } = (0, import_react.useContext)(MapContext);
	const thisRef = (0, import_react.useRef)({ props });
	thisRef.current.props = props;
	const marker = (0, import_react.useMemo)(() => {
		let hasChildren = false;
		import_react.Children.forEach(props.children, (el) => {
			if (el) hasChildren = true;
		});
		const options = {
			...props,
			element: hasChildren ? document.createElement("div") : null
		};
		const mk = new mapLib$1.Marker(options);
		mk.setLngLat([props.longitude, props.latitude]);
		mk.getElement().addEventListener("click", (e) => {
			var _a, _b;
			(_b = (_a = thisRef.current.props).onClick) === null || _b === void 0 || _b.call(_a, {
				type: "click",
				target: mk,
				originalEvent: e
			});
		});
		mk.on("dragstart", (e) => {
			var _a, _b;
			const evt = e;
			evt.lngLat = marker.getLngLat();
			(_b = (_a = thisRef.current.props).onDragStart) === null || _b === void 0 || _b.call(_a, evt);
		});
		mk.on("drag", (e) => {
			var _a, _b;
			const evt = e;
			evt.lngLat = marker.getLngLat();
			(_b = (_a = thisRef.current.props).onDrag) === null || _b === void 0 || _b.call(_a, evt);
		});
		mk.on("dragend", (e) => {
			var _a, _b;
			const evt = e;
			evt.lngLat = marker.getLngLat();
			(_b = (_a = thisRef.current.props).onDragEnd) === null || _b === void 0 || _b.call(_a, evt);
		});
		return mk;
	}, []);
	(0, import_react.useEffect)(() => {
		marker.addTo(map.getMap());
		return () => {
			marker.remove();
		};
	}, []);
	const { longitude, latitude, offset, style, draggable = false, popup = null, rotation = 0, rotationAlignment = "auto", pitchAlignment = "auto" } = props;
	(0, import_react.useEffect)(() => {
		applyReactStyle(marker.getElement(), style);
	}, [style]);
	(0, import_react.useImperativeHandle)(ref, () => marker, []);
	if (marker.getLngLat().lng !== longitude || marker.getLngLat().lat !== latitude) marker.setLngLat([longitude, latitude]);
	if (offset && !arePointsEqual(marker.getOffset(), offset)) marker.setOffset(offset);
	if (marker.isDraggable() !== draggable) marker.setDraggable(draggable);
	if (marker.getRotation() !== rotation) marker.setRotation(rotation);
	if (marker.getRotationAlignment() !== rotationAlignment) marker.setRotationAlignment(rotationAlignment);
	if (marker.getPitchAlignment() !== pitchAlignment) marker.setPitchAlignment(pitchAlignment);
	if (marker.getPopup() !== popup) marker.setPopup(popup);
	return (0, import_react_dom$1.createPortal)(props.children, marker.getElement());
}
var marker_default = (0, import_react.memo)((0, import_react.forwardRef)(Marker$1));

//#endregion
//#region node_modules/react-map-gl/dist/esm/components/popup.js
var import_react_dom = require_react_dom();
function getClassList(className) {
	return new Set(className ? className.trim().split(/\s+/) : []);
}
function Popup$1(props, ref) {
	const { map, mapLib: mapLib$1 } = (0, import_react.useContext)(MapContext);
	const container = (0, import_react.useMemo)(() => {
		return document.createElement("div");
	}, []);
	const thisRef = (0, import_react.useRef)({ props });
	thisRef.current.props = props;
	const popup = (0, import_react.useMemo)(() => {
		const options = { ...props };
		const pp = new mapLib$1.Popup(options);
		pp.setLngLat([props.longitude, props.latitude]);
		pp.once("open", (e) => {
			var _a, _b;
			(_b = (_a = thisRef.current.props).onOpen) === null || _b === void 0 || _b.call(_a, e);
		});
		return pp;
	}, []);
	(0, import_react.useEffect)(() => {
		const onClose = (e) => {
			var _a, _b;
			(_b = (_a = thisRef.current.props).onClose) === null || _b === void 0 || _b.call(_a, e);
		};
		popup.on("close", onClose);
		popup.setDOMContent(container).addTo(map.getMap());
		return () => {
			popup.off("close", onClose);
			if (popup.isOpen()) popup.remove();
		};
	}, []);
	(0, import_react.useEffect)(() => {
		applyReactStyle(popup.getElement(), props.style);
	}, [props.style]);
	(0, import_react.useImperativeHandle)(ref, () => popup, []);
	if (popup.isOpen()) {
		if (popup.getLngLat().lng !== props.longitude || popup.getLngLat().lat !== props.latitude) popup.setLngLat([props.longitude, props.latitude]);
		if (props.offset && !deepEqual(popup.options.offset, props.offset)) popup.setOffset(props.offset);
		if (popup.options.anchor !== props.anchor || popup.options.maxWidth !== props.maxWidth) {
			popup.options.anchor = props.anchor;
			popup.setMaxWidth(props.maxWidth);
		}
		if (popup.options.className !== props.className) {
			const prevClassList = getClassList(popup.options.className);
			const nextClassList = getClassList(props.className);
			for (const c of prevClassList) if (!nextClassList.has(c)) popup.removeClassName(c);
			for (const c of nextClassList) if (!prevClassList.has(c)) popup.addClassName(c);
			popup.options.className = props.className;
		}
	}
	return (0, import_react_dom.createPortal)(props.children, container);
}
var popup_default = (0, import_react.memo)((0, import_react.forwardRef)(Popup$1));

//#endregion
//#region node_modules/react-map-gl/dist/esm/components/use-control.js
function useControl(onCreate, arg1, arg2, arg3) {
	const context = (0, import_react.useContext)(MapContext);
	const ctrl = (0, import_react.useMemo)(() => onCreate(context), []);
	(0, import_react.useEffect)(() => {
		const opts = arg3 || arg2 || arg1;
		const onAdd = typeof arg1 === "function" && typeof arg2 === "function" ? arg1 : null;
		const onRemove = typeof arg2 === "function" ? arg2 : typeof arg1 === "function" ? arg1 : null;
		const { map } = context;
		if (!map.hasControl(ctrl)) {
			map.addControl(ctrl, opts === null || opts === void 0 ? void 0 : opts.position);
			if (onAdd) onAdd(context);
		}
		return () => {
			if (onRemove) onRemove(context);
			if (map.hasControl(ctrl)) map.removeControl(ctrl);
		};
	}, []);
	return ctrl;
}
var use_control_default = useControl;

//#endregion
//#region node_modules/react-map-gl/dist/esm/components/attribution-control.js
function AttributionControl$1(props) {
	const ctrl = use_control_default(({ mapLib: mapLib$1 }) => new mapLib$1.AttributionControl(props), { position: props.position });
	(0, import_react.useEffect)(() => {
		applyReactStyle(ctrl._container, props.style);
	}, [props.style]);
	return null;
}
var attribution_control_default = (0, import_react.memo)(AttributionControl$1);

//#endregion
//#region node_modules/react-map-gl/dist/esm/components/fullscreen-control.js
function FullscreenControl$1(props) {
	const ctrl = use_control_default(({ mapLib: mapLib$1 }) => new mapLib$1.FullscreenControl({ container: props.containerId && document.getElementById(props.containerId) }), { position: props.position });
	(0, import_react.useEffect)(() => {
		applyReactStyle(ctrl._controlContainer, props.style);
	}, [props.style]);
	return null;
}
var fullscreen_control_default = (0, import_react.memo)(FullscreenControl$1);

//#endregion
//#region node_modules/react-map-gl/dist/esm/components/geolocate-control.js
function GeolocateControl$1(props, ref) {
	const thisRef = (0, import_react.useRef)({ props });
	const ctrl = use_control_default(({ mapLib: mapLib$1 }) => {
		const gc = new mapLib$1.GeolocateControl(props);
		const setupUI = gc._setupUI;
		gc._setupUI = (args) => {
			if (!gc._container.hasChildNodes()) setupUI(args);
		};
		gc.on("geolocate", (e) => {
			var _a, _b;
			(_b = (_a = thisRef.current.props).onGeolocate) === null || _b === void 0 || _b.call(_a, e);
		});
		gc.on("error", (e) => {
			var _a, _b;
			(_b = (_a = thisRef.current.props).onError) === null || _b === void 0 || _b.call(_a, e);
		});
		gc.on("outofmaxbounds", (e) => {
			var _a, _b;
			(_b = (_a = thisRef.current.props).onOutOfMaxBounds) === null || _b === void 0 || _b.call(_a, e);
		});
		gc.on("trackuserlocationstart", (e) => {
			var _a, _b;
			(_b = (_a = thisRef.current.props).onTrackUserLocationStart) === null || _b === void 0 || _b.call(_a, e);
		});
		gc.on("trackuserlocationend", (e) => {
			var _a, _b;
			(_b = (_a = thisRef.current.props).onTrackUserLocationEnd) === null || _b === void 0 || _b.call(_a, e);
		});
		return gc;
	}, { position: props.position });
	thisRef.current.props = props;
	(0, import_react.useImperativeHandle)(ref, () => ctrl, []);
	(0, import_react.useEffect)(() => {
		applyReactStyle(ctrl._container, props.style);
	}, [props.style]);
	return null;
}
var geolocate_control_default = (0, import_react.memo)((0, import_react.forwardRef)(GeolocateControl$1));

//#endregion
//#region node_modules/react-map-gl/dist/esm/components/navigation-control.js
function NavigationControl$1(props) {
	const ctrl = use_control_default(({ mapLib: mapLib$1 }) => new mapLib$1.NavigationControl(props), { position: props.position });
	(0, import_react.useEffect)(() => {
		applyReactStyle(ctrl._container, props.style);
	}, [props.style]);
	return null;
}
var navigation_control_default = (0, import_react.memo)(NavigationControl$1);

//#endregion
//#region node_modules/react-map-gl/dist/esm/components/scale-control.js
function ScaleControl$1(props) {
	const ctrl = use_control_default(({ mapLib: mapLib$1 }) => new mapLib$1.ScaleControl(props), { position: props.position });
	const propsRef = (0, import_react.useRef)(props);
	const prevProps = propsRef.current;
	propsRef.current = props;
	const { style } = props;
	if (props.maxWidth !== void 0 && props.maxWidth !== prevProps.maxWidth) ctrl.options.maxWidth = props.maxWidth;
	if (props.unit !== void 0 && props.unit !== prevProps.unit) ctrl.setUnit(props.unit);
	(0, import_react.useEffect)(() => {
		applyReactStyle(ctrl._container, style);
	}, [style]);
	return null;
}
var scale_control_default = (0, import_react.memo)(ScaleControl$1);

//#endregion
//#region node_modules/react-map-gl/dist/esm/utils/assert.js
function assert(condition, message) {
	if (!condition) throw new Error(message);
}

//#endregion
//#region node_modules/react-map-gl/dist/esm/components/layer.js
function updateLayer(map, id, props, prevProps) {
	assert(props.id === prevProps.id, "layer id changed");
	assert(props.type === prevProps.type, "layer type changed");
	if (props.type === "custom" || prevProps.type === "custom") return;
	const { layout = {}, paint = {}, filter, minzoom, maxzoom, beforeId } = props;
	if (beforeId !== prevProps.beforeId) map.moveLayer(id, beforeId);
	if (layout !== prevProps.layout) {
		const prevLayout = prevProps.layout || {};
		for (const key in layout) if (!deepEqual(layout[key], prevLayout[key])) map.setLayoutProperty(id, key, layout[key]);
		for (const key in prevLayout) if (!layout.hasOwnProperty(key)) map.setLayoutProperty(id, key, void 0);
	}
	if (paint !== prevProps.paint) {
		const prevPaint = prevProps.paint || {};
		for (const key in paint) if (!deepEqual(paint[key], prevPaint[key])) map.setPaintProperty(id, key, paint[key]);
		for (const key in prevPaint) if (!paint.hasOwnProperty(key)) map.setPaintProperty(id, key, void 0);
	}
	if (!deepEqual(filter, prevProps.filter)) map.setFilter(id, filter);
	if (minzoom !== prevProps.minzoom || maxzoom !== prevProps.maxzoom) map.setLayerZoomRange(id, minzoom, maxzoom);
}
function createLayer(map, id, props) {
	if (map.style && map.style._loaded && (!("source" in props) || map.getSource(props.source))) {
		const options = {
			...props,
			id
		};
		delete options.beforeId;
		map.addLayer(options, props.beforeId);
	}
}
var layerCounter = 0;
function Layer$1(props) {
	const map = (0, import_react.useContext)(MapContext).map.getMap();
	const propsRef = (0, import_react.useRef)(props);
	const [, setStyleLoaded] = (0, import_react.useState)(0);
	const id = (0, import_react.useMemo)(() => props.id || `jsx-layer-${layerCounter++}`, []);
	(0, import_react.useEffect)(() => {
		if (map) {
			const forceUpdate = () => setStyleLoaded((version) => version + 1);
			map.on("styledata", forceUpdate);
			forceUpdate();
			return () => {
				map.off("styledata", forceUpdate);
				if (map.style && map.style._loaded && map.getLayer(id)) map.removeLayer(id);
			};
		}
	}, [map]);
	if (map && map.style && map.getLayer(id)) try {
		updateLayer(map, id, props, propsRef.current);
	} catch (error) {
		console.warn(error);
	}
	else createLayer(map, id, props);
	propsRef.current = props;
	return null;
}
var layer_default = Layer$1;

//#endregion
//#region node_modules/react-map-gl/dist/esm/components/source.js
var sourceCounter = 0;
function createSource(map, id, props) {
	if (map.style && map.style._loaded) {
		const options = { ...props };
		delete options.id;
		delete options.children;
		map.addSource(id, options);
		return map.getSource(id);
	}
	return null;
}
function updateSource(source, props, prevProps) {
	assert(props.id === prevProps.id, "source id changed");
	assert(props.type === prevProps.type, "source type changed");
	let changedKey = "";
	let changedKeyCount = 0;
	for (const key in props) if (key !== "children" && key !== "id" && !deepEqual(prevProps[key], props[key])) {
		changedKey = key;
		changedKeyCount++;
	}
	if (!changedKeyCount) return;
	const type = props.type;
	if (type === "geojson") source.setData(props.data);
	else if (type === "image") source.updateImage({
		url: props.url,
		coordinates: props.coordinates
	});
	else if ("setCoordinates" in source && changedKeyCount === 1 && changedKey === "coordinates") source.setCoordinates(props.coordinates);
	else if ("setUrl" in source && changedKey === "url") source.setUrl(props.url);
	else if ("setTiles" in source && changedKey === "tiles") source.setTiles(props.tiles);
	else console.warn(`Unable to update <Source> prop: ${changedKey}`);
}
function Source$1(props) {
	const map = (0, import_react.useContext)(MapContext).map.getMap();
	const propsRef = (0, import_react.useRef)(props);
	const [, setStyleLoaded] = (0, import_react.useState)(0);
	const id = (0, import_react.useMemo)(() => props.id || `jsx-source-${sourceCounter++}`, []);
	(0, import_react.useEffect)(() => {
		if (map) {
			const forceUpdate = () => setTimeout(() => setStyleLoaded((version) => version + 1), 0);
			map.on("styledata", forceUpdate);
			forceUpdate();
			return () => {
				var _a;
				map.off("styledata", forceUpdate);
				if (map.style && map.style._loaded && map.getSource(id)) {
					const allLayers = (_a = map.getStyle()) === null || _a === void 0 ? void 0 : _a.layers;
					if (allLayers) {
						for (const layer of allLayers) if (layer.source === id) map.removeLayer(layer.id);
					}
					map.removeSource(id);
				}
			};
		}
	}, [map]);
	let source = map && map.style && map.getSource(id);
	if (source) updateSource(source, props, propsRef.current);
	else source = createSource(map, id, props);
	propsRef.current = props;
	return source && import_react.Children.map(props.children, (child) => child && (0, import_react.cloneElement)(child, { source: id })) || null;
}
var source_default = Source$1;

//#endregion
//#region node_modules/react-map-gl/dist/esm/exports-mapbox.js
function useMap() {
	return useMap$1();
}
var mapLib = import("./mapbox-gl-CKjelue2.js").then(__toDynamicImportESM());
const Map = (() => {
	return import_react.forwardRef(function Map$2(props, ref) {
		return Map$1(props, ref, mapLib);
	});
})();
const Marker = marker_default;
const Popup = popup_default;
const AttributionControl = attribution_control_default;
const FullscreenControl = fullscreen_control_default;
const NavigationControl = navigation_control_default;
const GeolocateControl = geolocate_control_default;
const ScaleControl = scale_control_default;
const Layer = layer_default;
const Source = source_default;
var exports_mapbox_default = Map;

//#endregion
export { AttributionControl, FullscreenControl, GeolocateControl, Layer, Map, MapProvider, Marker, NavigationControl, Popup, ScaleControl, Source, exports_mapbox_default as default, use_control_default as useControl, useMap };
//# sourceMappingURL=react-map-gl.js.map