[TRA-10: Architecture Investigation](https://linear.app/traffic-jam/issue/TRA-10/investigation-map-out-a-high-level-architecture-of-the-system)

# Frame the Problem

We are building a traffic simulation web service with a 6-person team and a 2-month MVP deadline. We need an architecture that enables parallel work while keeping complexity manageable for our timeline.

---

### Why are we doing this work?

To document our architecture decisions and establish clear ownership boundaries before development begins.

### What outcome are we looking for?

1. A documented architecture that the whole team understands
2. Clear module boundaries and ownership for parallel development

## Architecture Overview

See [./arch.png](./arch.png) for the visual diagram.

## Decided Components

### Frontend: Static Vite App

A static single-page application built with Vite.

**Responsibilities:**

- Simulation configuration UI
- Results visualization
- User authentication flow (WorkOS OAuth)

**Deployment:** Static hosting (GCS bucket or Cloud Run)

---

### Authentication: WorkOS OAuth (Client-Side)

Client-side only OAuth flow using WorkOS.

**How it works:**

1. User initiates login in frontend
2. WorkOS handles OAuth flow
3. Frontend receives JWT
4. JWT is passed to backend with each request
5. Backend validates JWT

**Why WorkOS:** Managed auth with SSO support, minimal backend complexity.

---

### Backend: Modular Monolith

A single deployable backend with clear internal module boundaries.

**Main Modules/Sercvices:**

| Module                   | Responsibility                                  |
| ------------------------ | ----------------------------------------------- |
| **Auth Validation**      | Validate WorkOS JWTs, extract user context      |
| **API Handlers**         | REST endpoints for simulations, CRUD operations |
| **File Storage Manager** | GCS file operations                             |
| **Store Manager**        | DB queries                                      |
| **Task/Job Q Manager**   | Simulation job lifecycle, status management     |

**Why monolith:** Simpler deployment, easier debugging, sufficient for MVP scale. Internal modules still enable parallel development.

---

### Database Consideraions

**Tables/Collections:**

| Table             | Purpose                                           |
| ----------------- | ------------------------------------------------- |
| `users`           | User info, WorkOS ID, preferences                 |
| `simulation_jobs` | Simulation metadata, status, config, results path |

### Database choice

Option 1: Postgres
The team is familiar with Postgres and handles both relational data and JSONB for flexible simulation configs.
The schema is not yet known so flexibility is required.

Option 2: MongoDB
Object store database with flexible schemas by default.

| Criteria                     | Postgres                          | MongoDB                     |
| ---------------------------- | --------------------------------- | --------------------------- |
| 1. Can we model the data ?   | Yes, the model is simple          | Yes, the model is simple    |
| 2. Flexible config storage   | JSONB handles it                  | Native                      |
| 3.Atomic operations for JobQ | `FOR UPDATE SKIP LOCKED` built-in | Not built-in                |
| 4. Team familiarity          | Team is mostly familiar           | Team is mostly not familiar |
| **Decision**                 | ** Use Postgres**                 |                             |

(NOTE: Point 4 might not be needed if we use a separate JobQ like Pub/Sub, RabbitMQ, Apache Kafka, or something else, but this will expand the infrastructure complexity)

### Tracing & Logging: Wide event logging via OpenTelemetry

Industry standard for tracing and logging.
Has a wide variety of integrations with other tools and SDK for every possible language we might want to use.

### File Storage: GCS Bucket

Stores simulation input files and output results.

**Structure:**

```
bucket/
├── inputs/
│   └── {user_id}/{simulation_id}/
│       ├── some files
└── outputs/
    └── {user_id}/{simulation_id}/
│       ├── some files
```

Why GCS: Cost effective and easy to set up, signed URLs for secure access.

### Simulation Pipeline Service

Separate service that runs our simulation engine of choice

**Responsibilities:**

- Receive simulation config from backend
- Execute the simulation with provided parameters on the simulation engine
- Return results to the backend
- Store any files generated by the simulation in GCS

**Why separate service:** Two reasons:

1. Separation of concerns: This will allows to parallelize the work between the backend and simulation engine.
2. Isolation: Simulation engine is resource-intensive (CPU/memory). Isolation prevents simulation load from affecting API performance. And we can always scale the engine seperately from the backend.

---

## Open Decisions

### Task Queue Strategy

We have not yet decided how to handle job task queuing between the backend and simulation pipeline. Options under consideration include simple Postgres polling, Cloud Tasks, or Cloud Pub/Sub or PGMQ (a postgres message queue extension).

This will be documented in a separate investigation.
